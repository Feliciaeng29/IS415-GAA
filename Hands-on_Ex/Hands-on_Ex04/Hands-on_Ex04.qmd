---
title: "Hands on Exercise 4: Spatial Weights and Applications"
categories: ["Hands-on Exercise", "rgdal", "sf", "spdep", "tmap", "tidyverse", "knitr", "sp", "spNetwork", "spatial weights and applications", "choropleth map"]
---

# Importing Packages

The R packages we'll be introducing today are:

-   [**spdep**](https://cran.r-project.org/web/packages/spdep/index.html): used to create spatial weights matrix objects and related calculations (e.g. spatially lag attributes)

In addition, we'll be using the packages from our previous lessons:

-   [**sf**](https://cran.r-project.org/web/packages/sf/index.html): used for importing, managing, and processing geospatial data
-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html): used for plotting thematic maps, such as choropleth and bubble maps
-   [**tidyverse**](https://www.tidyverse.org/): used for importing, wrangling and visualising data (and other data science tasks!)

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

# Getting data into R environment

The datasets used for this exercise are:

-   `Hunan_2012` (aspatial data): a .csv which stores Hunan's local development indicators in 2012
-   `Hunan` (geospatial data): an ESRI shapefile which stores Hunan's country boundary layers

## Importing shapefile into r environement

Let's import our aspatial and geospatial data per usual:

```{r}
#output: simple features object
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
```

## Import csv file into r environment

```{r}
#output: R dataframe class
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

Lets remember that for data: - geospatial data: st_read() - attribute data: read_csv()

## Data preparation

### Import csv file into r environment & performing a relational join

```{r}
hunan <- left_join(hunan,hunan2012)
knitr::kable(head(hunan, n=5))
```

## Visualing Regional Development Indicator

Lets prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

# Computing Contiguity Spatial Weights

-   Use **poly2nb() of spdep** package to compute **contiguity weight matrices** for the study area.

-   poly2nb(): Construct neighbours list from polygon list

-   This function **builds a neighbours list** based on regions with contiguous boundaries.

What this function does is to build a neighbours list based on regions with contiguous boundaries - which means they’re in ‘contact’ and share one or more boundary points. For example, on the Singapore map, the North-East region is contiguous with the North region and the East region.

One thing to note is the `queen` argument:

-   TRUE (default): a single shared boundary point meets the contiguity condition

-   FALSE: more than one shared point is required

-   note that more than one shared boundary point does not necessarily mean a shared boundary line

We’ll be computing based on two types of contiguity: Queen and Rook. If you’re a chess buff (or even a chess amateur), these terms will sound familiar to you: and as you might’ve guessed, they’re related to the positions the queen and rook can move on a chess board.

## Computing (QUEEN) contiguity based neighbours

NOTE:

-   The default for 'queen' argument is TRUE.
-   If you do not specify to queen = FALSE, this function will **return a list of first order neighbours** using the Queen criteria.

```{r eval=TRUE, echo = TRUE}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

-   Summary report above shows that there are **88 area units** in Hunan (look at the no. of regions).
-   The **most connected area unit** has **11 neighbours** (look at 1 most connected region and the link).
-   There are 2 area units with only 1 neighbours (look at 2 least connected regions and the link)

### List the neighbouring polygons

-   For each polygon in our polygon object, wm_q lists all neighboring polygons.
-   To see the neighbors for the first polygon in the object, type:

```{r eval=TRUE, echo = TRUE}
wm_q[[1]]
```

-   Results above show that **Polygon 1 has 5 neighbors**.
-   The **numbers** represent the **polygon IDs** as stored in hunan SpatialPolygonsDataFrame class

### Retrieve the county name of Polygon ID=1

```{r eval=TRUE, echo = TRUE}
hunan$County[1]
```

### Reveal county names of the 5 neighboring polygons

```{r eval=TRUE, echo = TRUE}
hunan$NAME_3[c(2,3,4,57,85)]
```

### Display the complete weight matrix by using str()

```{r eval=TRUE, echo = TRUE}
str(wm_q)
```

## Computing (ROOK) contiguity based neighbours

-   Note: See that we set the queen argument to FALSE

```{r eval=TRUE, echo = TRUE}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

-   Summary report above shows that there are **88 area units** in Hunan (look at the no. of regions).
-   The **most connected area unit** has **10 neighbours** (look at 1 most connected region and the link).
-   There are 2 area units with only 1 neighbour (look at 2 least connected regions and the link)

## Visualising contiguity weights

-   As we are working with polygons, we need to get points in order to make the **connectivity graphs**.
-   Most typical method: **polygon centroids**
    -   Calculate these in the sf package before moving onto the graphs
    -   Getting Latitude and Longitude of Polygon Centroids
    -   It is a little more complicated than just running st_centroid on the sf object as we need to get the coordinates in a separate data frame..
-   **Mapping function**: applies a given function to each element of a vector and returns a vector of the same length.
-   **input vector**: will be the geometry column of us.bound.
-   **function** will be st_centroid.
-   Use **map_dbl** variation of map from the purrr package

### Get only the longitude

-   To get our longitude values, we map the st_centroid function over the geometry column of us.bound and access the longitude value through double bracket notation \[\[\]\] and 1.
-   Allows us to get only the longitude, which is the first value in each centroid.

```{r eval=TRUE, echo = TRUE}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

### Get only the latitude

-   Do the same for latitude with one key difference.
-   We access the second value per each centroid with \[\[2\]\]

```{r eval=TRUE, echo = TRUE}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

### Put longitude and latitude into the same object

-   Use cbind to put longitude and latitude into the same object.

```{r eval=TRUE, echo = TRUE}
coords <- cbind(longitude, latitude)
```

### Check the first few observations

-   Check the first few observations to see if things are formatted correctly

```{r eval=TRUE, echo = TRUE}
head(coords)
```

### Plot Queen & Rook contiguity based neighbours maps (there is a difference)

```{r eval=TRUE, echo = TRUE}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red", main="Queen Contiguity")
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red", main="Rook Contiguity")
```

**NOTE**:

-   There is actually a difference if you look closely at the bottom right of Queen Contiguity plot.
-   There is 2 extra verticies at the bottom right.

## Compute distance based neighbours

-   Derive **distance-based weight matrices** by using **dnearneigh()** of spdep package
-   The function identifies neighbours of region points by Euclidean distance with a distance band with **lower d1= and upper d2= bounds** controlled by the bounds= argument.
-   If unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid.

### Determine the cut-off distance

-   To determine the upper limit for distance band:
    -   Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using **knearneigh()** of spdep.
    -   Convert the knn object returned by **knearneigh()** into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using **knn2nb()**.
    -   Return the length of neighbour relationship edges by using **nbdists()** of spdep. The function returns in the units of the coordinates if the coordinates are projected, in km otherwise.
    -   Remove the list structure of the returned object by using **unlist()**.

```{r eval=TRUE, echo = TRUE}
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

-   Summary report shows that the largest first nearest neighbour distance is **61.79 km**, so using this as the upper threshold gives **certainty** that all units will have at least one neighbour.

### Computing fixed distance weight matrix using **dnearneigh()**

```{r eval=TRUE, echo = TRUE}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```

Quiz: What is the meaning of *Average number of links: 3.681818* shown above? - It means that on average, there are about 3 neighbours in each region areas.

### Use str() to display the content of wm_d62 weight matrix

```{r eval=TRUE, echo = TRUE}
str(wm_d62)
```

### Display structure of weight matrix

-   Another way to display the structure of the weight matrix is to combine table() and card() of spdep.

```{r eval=TRUE, echo = TRUE}
table(hunan$County, card(wm_d62))
```

### Plotting fixed distance weight matrix

```{r eval=TRUE, echo = TRUE, fig.width=12, fig.height=8}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```

-   The **red** lines above show the **links of 1st nearest neighbours**
-   The **black** lines show the **links of neighbours within the cut-off distance of 62km**.
-   Alternatively, we can plot both of them next to each other:

```{r eval=TRUE, echo = TRUE}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(k1, coords, add=TRUE, col="red", length=0.08, main="1st nearest neighbours")
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main="Distance link")
```

### Computing adaptive distance weight matrix

-   1 of the characteristics of fixed distance weight matrix is that **more densely settled areas** (usually the urban areas) tend to have **more neighbours**
-   and the **less densely settled areas** (usually the rural counties) **tend to have lesser neighbours**.
-   Having many neighbours smoothes the neighbour relationship across more neighbours.

#### Control the numbers of neighbours directly

-   It is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry

```{r eval=TRUE, echo = TRUE}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
```

Display the content of the matrix by using str():

```{r eval=TRUE, echo = TRUE}
str(knn6)
```

-   Notice that each county has 6 neighbours

### Plotting distance based neighbours

-   Plot the weight matrix

```{r eval=TRUE, echo = TRUE}
plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

## Weights based on IDW (Inverse Distance)

-   Here, we will derive a spatial weight matrix based on **Inversed Distance** method.

### Compute the distances between areas by using **nbdists()** of spdep.

```{r eval=TRUE, echo = TRUE}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

## Row-standardised weights matrix

-   Need to assign weights to each neighboring polygon.
-   The most intuitive way to summarize the neighbours’ values:
    -   Assigning the fraction 1/(no. of neighbours) to each neighbouring county
    -   Summing the weighted income values
    -   This can be done by assigning each neighboring polygon **equal weight (style=“W”)**
-   This method has 1 drawback:
    -   Polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data.
    -   For this example, we’ll stick with the style=“W” option for simplicity’s sake but note that other more robust options are available, notably **style=“B”**
-   The zero.policy=TRUE option allows for lists of non-neighbors.
-   This should be used with caution since the user may not be aware of missing neighbors in their dataset
-   However, a zero.policy of FALSE would return an error

### Equal weight

```{r eval=TRUE, echo = TRUE}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
```

-   To see the weight of the first polygon’s four neighbors type

```{r eval=TRUE, echo = TRUE}
rswm_q$weights[10]
```

-   Each neighbor is assigned a 0.2 of the total weight.
-   When computing the average neighboring income values, each neighbor’s income will be multiplied by 0.2 before being tallied.

### Row standardised distance weight matrix

-   Using the same method, we can also derive a row standardised distance weight matrix by using the code chunk below.

```{r eval=TRUE, echo = TRUE}
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
```

```{r eval=TRUE, echo = TRUE}
rswm_ids$weights[1]
```

```{r eval=TRUE, echo = TRUE}
summary(unlist(rswm_ids$weights))
```

# Application of Spatial Weight Matrix

**We will create 4 different spatial lagged variables:**

-   spatial lag with row-standardized weights
-   spatial lag as a sum of neighbouring values
-   spatial window average, and
-   spatial window sum

Note:

[What is a spatially lagged variable?]{.underline}

-   With a neighbor structure defined by the non-zero elements of the spatial weights matrix W, a spatially lagged variable is a weighted sum or a weighted average of the neighbouring values for that variable.

## Spatial lag with row-standardized weights

### compute the average neighbor GDPPC

-   Here, we compute the average neighbor GDPPC value for each polygon.
-   These values are often referred to as **spatially lagged values**

```{r eval=TRUE, echo = TRUE}
GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)
GDPPC.lag
```

### Append spatially lag GDPPC values onto hunan SpatialPolygonDataFrame

```{r eval=TRUE, echo = TRUE}
lag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")
hunan <- left_join(hunan,lag.res)
```

-   The following table shows the average neighboring income values (stored in the Inc.lag object) for each county.

```{r eval=TRUE, echo = TRUE}
head(hunan)
```

### Plot both the GDPPC and spatial lag GDPPC for comparison

```{r eval=TRUE, echo = TRUE, fig.width=12, fig.height=8}
gdppc <- qtm(hunan, "GDPPC")
lag_gdppc <- qtm(hunan, "lag GDPPC")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)
```

## Spatial window sum

-   The spatial window sum uses and includes the diagonal element.

### Assign knn6 to a new variable

-   Why? Because we will directly alter its structure to add the diagonal elements

```{r eval=TRUE, echo = TRUE}
knn6a <- knn6
```

### Add diagonal element to neighbour list using **include.self()** from spdep.

```{r eval=TRUE, echo = TRUE}
include.self(knn6a)
```

### Assign binary weights to the neighbour structure that includes the diagonal element

```{r eval=TRUE, echo = TRUE}
binary.knn6 <- lapply(knn6a, function(x) 0*x+1)
binary.knn6[1]
```

### Use **nb2listw() and glist()** to explicitly assign weight values.

-   nb2listw(): Spatial weights for neighbours lists

```{r eval=TRUE, echo = TRUE}
wm_knn6 <- nb2listw(knn6a, glist = binary.knn6, style = "B")
```

### Compute the lag variable with lag.listw()

-   With our new weight structure, we can compute the lag variable with lag.listw().

```{r eval=TRUE, echo = TRUE}
lag_knn6 <- lag.listw(wm_knn6, hunan$GDPPC)
```

### Convert lag variable listw object into a data.frame by using **as.data.frame()**

```{r eval=TRUE, echo = TRUE}
lag.list.knn6 <- list(hunan$NAME_3, lag.listw(wm_knn6, hunan$GDPPC))
lag_knn6.res <- as.data.frame(lag.list.knn6)
colnames(lag_knn6.res) <- c("NAME_3", "lag_sum GDPPC")
```

**Note:** The third line of code in the code chunk above **renames** the field names of lag_knn6.res object into NAME_3 and lag_sum GDPPC respectively.

### Append lag_sum GDPPC values onto hunan sf data.frame by using **left_join()** of dplyr package

```{r eval=TRUE, echo = TRUE}
hunan <- left_join(hunan, lag_knn6.res)
```

### Plot the GDPPC and lag_sum GDPPC map

-   Lastly, `qtm()` of **tmap** package is used to plot the GDPPC and lag_sum GDPPC map next to each other for quick comparison.

```{r eval=TRUE, echo = TRUE, fig.width=12, fig.height=8}
gdppc <- qtm(hunan, "GDPPC")
lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)
```

**NOTE**: For more effective comparison, it is advisable to use the core tmap mapping functions.

# What I have learnt:

-   import geospatial data using appropriate function(s) of **sf** package,

-   import csv file using appropriate function of **readr** package,

-   perform relational join using appropriate join function of **dplyr** package,

-   compute spatial weights using appropriate functions of **spdep** package, and

-   calculate spatially lagged variables using appropriate functions of **spdep** package.
