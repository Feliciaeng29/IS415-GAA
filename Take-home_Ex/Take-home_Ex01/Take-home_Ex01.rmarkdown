---
title: "Take home Exercise 1: Application of Spatial Point Patterns Analysis to discover the geographical distribution of Grab hailing services in Singapore"
author:
  - name: Felicia Eng
date: "January 2024"
date-modified: "`r Sys.Date()`"
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---


## **Objectives**

Geospatial analytics hold tremendous potential to address complex problems facing society. In this study, you are tasked to apply appropriate spatial point patterns analysis methods to discover the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore.

## **The Task**

The specific tasks of this take-home exercise are as follows:

-   Using appropriate function of **sf** and **tidyverse**, preparing the following geospatial data layer in sf tibble data.frames:

    -   Grab taxi location points either by origins or destinations.

    -   Road layer within Singapore excluding outer islands.

    -   Singapore boundary layer excluding outer islands

-   Using the extracted data, derive traditional Kernel Density Estimation layers. (Hands-on ex3:1st order)

-   Using the extracted data, derive either Network Kernel Density Estimation (NKDE) or Temporal Network Kernel Density Estimation (TNKDE)

-   Using appropriate **tmap** functions, display the kernel density layers on openstreetmap of Singapore.

-   Describe the spatial patterns revealed by the kernel density maps.

# **Import R packages**

The different R packages used:

1.  **sf**: This package is used for importing, managing, and processing geospatial data. It provides classes and methods for working with spatial data in a simple and efficient manner.

2.  **tidyverse**: While not a single package, the tidyverse is a collection of R packages (including dplyr, ggplot2, tidyr, etc.) that share common principles for data manipulation and visualization. It's known for its user-friendly syntax and consistency.

3.  **tmap**: tmap is a package used for creating thematic maps. It provides a flexible and easy-to-use framework for visualizing spatial data, allowing users to create informative and visually appealing maps.

4.  **maptools**: This package offers a set of tools for manipulating geographic data. It includes functions for reading and writing spatial data in various formats, as well as tools for geometric operations on spatial data.

5.  **raster**: The raster package is designed for working with gridded spatial data. It allows users to read, write, manipulate, analyze, and model raster data, which is commonly used in fields like remote sensing and environmental sciences.

6.  **spatstat**: spatstat is used for performing spatial point pattern analysis. It provides a comprehensive set of tools for statistical analysis of point patterns, which is useful in fields such as ecology, epidemiology, and geography.

7.  **sfdep**: This package appears to be specific to your project and may not be a widely known package as of my last knowledge update in January 2022. It seems to be used for analyzing spatial dependencies, possibly building on or extending functionality provided by other spatial analysis packages.

8.  **pacman**: The **`pacman`** package is a convenient tool for managing and loading R packages. It allows you to install and load multiple packages in a single line of code.


```{r}
pacman::p_load(maptools, tmap, tidyverse, sf, raster, smoothr, spatstat, RColorBrewer, viridis, stringr, classInt, spNetwork, tmap,lubridate, arrow, sp, dplyr, rvest, nngeo)
```


# **The Data**

### **Apstial data**

-   For the purpose of this assignment, [Grab-Posisi](https://engineering.grab.com/grab-posisi) of Singapore will be used.

### **Geospatial data**

-   Road data set from OpenStreetMap of [Geofabrik download server](https://download.geofabrik.de/). The Malaysia, Singapore, and Brunei coverage should be downloaded.

-   Master Plan 2019 Subzone Boundary (No Sea) from Data.gov.sg.

# **Importing Data**

## Importing Aspatial Data (Grab)

### Importing Grab-Posisi Dataset

In this case we use **arrow** package *`read_parquet()`* function to import the following dataset.


```{r}
grab <- read_parquet("data/apstial/GrabPosisi/part-00000.parquet")
```


## Importing Geospatial data

### Importing Master Plan 2019 Subzone Boundary (No Sea) from Data.gov.sg.


```{r}
mpsz = st_read("data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml") %>%
  st_transform(crs=3414)
```


### Importing data for Road data from OpenStreetMap

In this case we will only be using the road data


```{r}
road <- st_read(dsn = "data/geospatial", layer = "gis_osm_roads_free_1") %>%
  st_transform(crs=3414)
```


# Data Preparation

## Aspatial (grab)

Now we will use glimpse() of dplyr package is used to display the structure of df tibble data.frame.


```{r}
glimpse(grab)
```


Notice that pingtimestamp is in wrong data type format. It should be in date/ time format and not integer.

### Converting data type to date/time format for grab data

Since pingtimestamp is in wrong data type format, we need to convert the data type of pingtimestamp from character to date-time.


```{r}
grab$pingtimestamp <- as_datetime(grab$pingtimestamp)
```


Save the tidy data.frame into rds format for subsequent use. Save the reformatted df into a new rds file called part0.rds. Save the output into a sub-folder call rds.


```{r}
write_rds(grab, "data/rds/part0.rds")
```


# Task 1: Grab taxi location points either by origins or destinations.

## Extracting trips' origin locations


```{r}
origin_df <- grab %>% 
  group_by(trj_id) %>% 
  arrange(pingtimestamp) %>% 
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label=TRUE,
                        abbr=TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
```


## Extracting trips' destination locations

Extracting trips' destination locations & converting destination_df into an sf tibble data.frame by using it’s location information.


```{r}
destination_df <- grab %>%
  group_by(trj_id) %>%
  arrange(desc(pingtimestamp)) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label=TRUE,
                        abbr=TRUE),
         end_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))

```


### Convert Aspatial to Geospatial for GrabPosisi

Convert origin_df into an sf tibble data.frame by using it’s location information.


```{r}
origin_df <- st_as_sf(origin_df,
                      coords = c("rawlng", "rawlat"),
                      crs = 4326) %>%
  st_transform(crs = 3414)
```

```{r}
destination_df <- st_as_sf(destination_df,
                      coords = c("rawlng", "rawlat"),
                      crs = 4326) %>%
  st_transform(crs = 3414)
```


## Selecting the relevant information for Grab

In this case, we do not need variables like driving_mode, osname, speed, bearing, accuracy


```{r}
columns_to_drop <- c("driving_mode", "osname", "speed", "bearing", "accuracy")

origin_df <- origin_df %>%
  dplyr::select(-one_of(columns_to_drop))
```

```{r}
columns_to_drop <- c("driving_mode", "osname", "speed", "bearing", "accuracy")

destination_df <- destination_df %>%
  dplyr::select(-one_of(columns_to_drop))
```


### Saving data from future use


```{r}
write_rds(origin_df, "data/rds/origin_df.rds")
write_rds(destination_df, "data/rds/destination_df.rds")
```


### Importing the origin and destination data


```{r}
origin_df <- read_rds("data/rds/origin_df.rds")
destination_df <- read_rds("data/rds/destination_df.rds")
```


### Visualising the data for Origin and Destination

#### Visualising frequency distribution

Here we are going to use ggplot functions are used to reveal the distribution of origin trips by day of the week.


```{r}
ggplot(data=origin_df, 
       aes(x=weekday)) + 
  geom_bar()
```


Here we are going to use ggplot functions are used to reveal the distribution of destination trips by day of the week.


```{r}
ggplot(data=destination_df, 
       aes(x=weekday)) + 
  geom_bar()
```


#### Visualising as Point Symbol Map


```{r}
tmap_mode("plot")
tm_shape(origin_df) +
  tm_dots()
```

```{r}
tmap_mode("plot")
tm_shape(destination_df) +
  tm_dots()
```


## Geospatial

### 1. mpsz data


```{r}
glimpse(mpsz)
```


### Selecting and cleaning the data

Using the rvest package, which is designed for web scraping but can also be useful for parsing HTML-like structures.


```{r}
mpsz <- mpsz %>%
  mutate(Match = map(Description, ~ {
    html <- read_html(.x)
    data <- html_nodes(html, "td") %>% html_text() %>% trimws()
    setNames(data, c("SUBZONE_NO", "SUBZONE_N", "SUBZONE_C", "CA_IND", "PLN_AREA_N", "PLN_AREA_C", "REGION_N", "REGION_C", "INC_CRC", "FMEL_UPD_D"))
  })) %>%
  unnest_wider(Match) %>%
  st_as_sf()
```


Filtering and selecting only the relevant information


```{r}
mpsz <- mpsz %>% dplyr::select('Name', 'geometry', 'SUBZONE_NO', 'SUBZONE_N', 'PLN_AREA_N', 'PLN_AREA_C', 'REGION_N', 'REGION_C')
```


### Filtering out the invalid geometries and dropping the z coordinates

Filters out invalid geometries, and the subsequent operations are performed on the remaining valid geometries. This approach can be more concise and may help avoid potential issues with invalid geometries.


```{r}
mpsz <- mpsz %>%
  filter(st_is_valid(.)) %>%  # Filter out invalid geometries
  st_make_valid() %>%         # Make valid
  st_zm() 
```


### 2. Open Street Map (road) data

### Selecting and cleaning relevant information

Filtering road data using the fclass selection

https://www.geofabrik.de/data/geofabrik-osm-gis-standard-0.3.pdf


```{r}
selected_data <- c("service", "tertiary", "primary_link", "motorway", "motorway_link", "tertiary_link", "living_street", "trunk", "trunk_link", "primary", "secondary", "residential")

road <- subset(road, fclass %in% selected_data)
```


# Boundary of SG

## Outer island removal and hole fixing

The code removes the outer islands from the mpsz object and fills any holes in the remaining polygon. The resulting polygon is then converted to an sf object and plotted.

Combine geometries and cast to POLYGON


```{r}
unioned_polygon <- st_union(mpsz) %>%
  st_cast("POLYGON")
```


Fill holes in the unioned polygon with a threshold of 1 square kilometer


```{r}
filled_polygon <- fill_holes(unioned_polygon, units::set_units(1, "km^2"))
```


Convert filled polygon to Simple Features (SF) object


```{r}
filled_sf <- st_as_sf(filled_polygon)
```


Plotting to visualise


```{r}
# Set up a side-by-side plot
par(mfrow = c(1, 2))

# Plot the original geometry
plot(st_geometry(mpsz), main = "Original Geometry")

# Plot the merged geometry with holes filled
plot(st_geometry(filled_sf), main = "Merged with Holes Filled")
```


## Creating an owin object (applying the outline)

The code creates an owin object from the merged polygon. This object is used to remove data on Malaysian and Bruneian roads from the osm object.

Then the code reads in the owin object and uses it to remove the data on Malaysian and Bruneian roads from the osm object.


```{r}
# Convert filled_sf to Spatial object for spatstat compatibility
merged_spatial <- as_Spatial(filled_sf)

# Convert Spatial object to SpatialPolygons
outline_polygons <- as(merged_spatial, "SpatialPolygons")

# Convert SpatialPolygons to owin object
outline_owin <- as(outline_polygons, "owin")

# Save the owin object to an RDS file for future use
write_rds(outline_owin, "data/rds/outline_owin.rds")

# Read the saved owin object from the RDS file
outline_owin <- read_rds("data/rds/outline_owin.rds")

# Use the outline to spatially constrain the road data
road_sg <- st_intersection(road, filled_sf)
```


Let us check the summary of road_sg


```{r}
road_sg_summary <- summary(road_sg)
```


I realised that some shapes were stored as multilinestrings which might cause the error in calculations. Hence, we need to split the multilinestrings into separate linestrings.

Identify and convert MULTILINESTRINGs to LINESTRINGs


```{r}
road_sg <- st_cast(st_cast(road_sg, "MULTILINESTRING"), "LINESTRING")
```


Check the summary of the processed road_sg


```{r}
processed_road_sg_summary <- summary(road_sg)
```


Now lets us save it in rds


```{r}
write_rds(road_sg, "data/rds/road_sg.rds")
road_sg <- read_rds("data/rds/road_sg.rds")
```


# **Data Preprocessing**

## Project Transformation

Before, we proceed lets use double check and make sure that all the data are projected in the same projection system.

We can do so using st_crs() function


```{r}
st_crs(origin_df)
```

```{r}
st_crs(destination_df)
```

```{r}
st_crs(road_sg)
```


# Data Wrangling

## Converting to sp’s Spatial\* class

Uses as_Spatial() of sf package to convert to sp’s Spatial\* class.


```{r}
origin <- as_Spatial(origin_df)
destination <- as_Spatial(destination_df)
```


Now, we will display the information about these Spatial\* class


```{r}
origin
```

```{r}
destination
```

```{r}
plot(origin)
```

```{r}
plot(destination)
```


We can see and make sure that the geospatial data have been converted into their respective sp's Spatial classes now

## Converting the Spatial\* class into generic sp format

spatstat requires the analytical data in ppp object form. There is no direct way to convert a Spatial\* classes into ppp object. We need to convert the Spatial classes\* into Spatial object first.


```{r}
origin_sp <- as(origin, "SpatialPoints")
destination_sp <- as(destination, "SpatialPoints")
```


Let us double check the sp objects properties:


```{r}
origin_sp
```

```{r}
destination_sp
```


## Converting the generic sp format into spatstat’s ppp format


```{r}
origin_ppp <- as(origin_sp, "ppp")
destination_ppp <- as(destination_sp, "ppp")
```


Lets plot to examine:


```{r}
plot(origin_ppp)
```

```{r}
plot(destination_ppp)
```


Lets look at the summary statistics of the newly created ppp object:


```{r}
summary(origin_ppp)
```

```{r}
summary(destination_ppp)
```


Notice if there is any duplicates. In spatial point patterns analysis an issue of significant is the presence of duplicates. The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are simple, that is, that the points cannot be coincident.

## Handling duplicated points

To check the duplication in a ppp object:


```{r}
any(duplicated(origin_ppp))
```

```{r}
any(duplicated(destination_ppp))
```


To count the number of co-indicence point, we will use the multiplicity() function:


```{r}
multiplicity(origin_ppp)
```

```{r}
multiplicity(destination_ppp)
```


How many locations have more than one point event


```{r}
sum(multiplicity(origin_ppp) > 1)
```

```{r}
sum(multiplicity(destination_ppp) > 1)
```


## Combining point events object and owin object

Filters points in origin_ppp and destination_ppp to retain only those within the spatial boundaries defined by outline_owin, effectively constraining the points to a specific region, likely Singapore.


```{r}
origin_ppp <- origin_ppp[outline_owin]
```


Let's us take a look at how origin looks like


```{r}
plot(origin_ppp)
```

```{r}
destination_ppp <- destination_ppp[outline_owin]
```


Let's us take a look at how destination looks like


```{r}
plot(destination_ppp)
```


Now let's take a look at the output


```{r}
summary(origin_ppp)
```

```{r}
summary(destination_ppp)
```


# First-order Spatial Point Patterns Analysis

## Kernel Density Estimation

### Rescalling KDE values

Rescale the spatial coordinates of the origin & desination point pattern to kilometers


```{r}
origin_ppp.km <- rescale(origin_ppp, 1000, "km")
```

```{r}
destination_ppp.km <- rescale(destination_ppp, 1000, "km")
```


Computes a kernel density by using the following configurations of [*density()*](https://rdrr.io/cran/spatstat/man/density.ppp.html) of **spatstat**:

-   [*bw.diggle()*](https://rdrr.io/cran/spatstat/man/bw.diggle.html) automatic bandwidth selection method. Other recommended methods are [*bw.CvL()*](https://rdrr.io/cran/spatstat/man/bw.CvL.html), [*bw.scott()*](https://rdrr.io/cran/spatstat/man/bw.scott.html) or [*bw.ppl()*](https://rdrr.io/cran/spatstat/man/bw.ppl.html).

-   The smoothing kernel used is *gaussian*, which is the default. Other smoothing methods are: “epanechnikov”, “quartic” or “disc”.

-   The intensity estimate is corrected for edge effect bias by using method described by Jones (1993) and Diggle (2010, equation 18.9). The default is *FALSE*.


```{r}
kde_origin_bw <-  density(origin_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
kde_destination_bw <-  density(destination_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```


Using plot() to display the kernel density derived


```{r}
plot(kde_origin_bw)
```

```{r}
plot(kde_destination_bw)
```


### Using quartic


```{r}
kde_origin_bw_quartic <-  density(origin_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="quartic") 
```

```{r}
kde_destination_bw_quartic <-  density(destination_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="quartic") 
```


Using plot() to display the kernel density derived


```{r}
plot(kde_origin_bw)
```

```{r}
plot(kde_destination_bw)
```

### Calculating Bandwidth

Let us take a look at the bandwidth return:


```{r}
bw.ppl(origin_ppp.km)
```

```{r}
bw.diggle(origin_ppp.km)
```

```{r}
bw.ppl(destination_ppp.km)
```

```{r}
bw.diggle(destination_ppp.km)
```


Comparing between the different output


```{r}
kde_origin.ppl <- density(origin_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_origin_bw, main = "bw.diggle")
plot(kde_origin.ppl, main = "bw.ppl")
```

```{r}
kde_destination.ppl <- density(destination_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_destination_bw, main = "bw.diggle")
plot(kde_destination.ppl, main = "bw.ppl")
```

```{r}
sigma_scale <- 0.65
origin_ppp.km <- rescale(origin_ppp, 1000, "km")

origin.bw <- density(origin_ppp.km,
                              sigma=sigma_scale,
                              edge=TRUE,
                            kernel="gaussian") 
plot(origin.bw)

```

```{r}
destination_ppp.km <- rescale(destination_ppp, 1000, "km")

destination.bw <- density(destination_ppp.km,
                              sigma=sigma_scale,
                              edge=TRUE,
                            kernel="gaussian") 
plot(destination.bw)
```


Zones to choose for NKDE: "WOODLANDS", "BUKIT MERAH", "CHANGI" , "SEMBAWANG", "YISHUN"



```{r}
sort(unique(mpsz$PLN_AREA_N))
```


# NKDE

## Preparing data

# Restrict the area of our NKDE to CHANGI
mpsz_changi <- mpsz %>% filter(PLN_AREA_N == "CHANGI")

# Remove small rocks or outer islands on the map by taking the intersection with merged_sg (Our outline)
mpsz_changi <- st_intersection(mpsz_changi, merged_sf)

# Take only the roads that come into contact with Changi
osm_changi <- st_intersection(osm_sg, mpsz_changi)

# Take only the events that happened within Changi
destination_df.changi <- st_intersection(destination_df, mpsz_changi)
origin_df.changi <- st_intersection(origin_df, mpsz_changi)

# As part of NKDE, the events need to have happened on the network. As such, we use snapPointsToLines2 to ensure that the points are on the network. Points off the network may have occurred due to slight GPS drift.
origin_df.changi.snapped <- snapPointsToLines2(origin_df.changi, osm_changi)
destination_df.changi.snapped <- snapPointsToLines2(destination_df.changi, osm_changi)

# Visualize the events at Changi, especially the airport
tm_shape(osm_changi) + 
  tm_lines() +
tm_shape(destination_df.changi.snapped) +
  tm_dots(col = "red") +
tm_shape(origin_df.changi.snapped) +
  tm_dots(col = "blue")


```{r}


```

