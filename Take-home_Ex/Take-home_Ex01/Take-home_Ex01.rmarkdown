---
title: "Take home Exercise 1: Application of Spatial Point Patterns Analysis to discover the geographical distribution of Grab hailing services in Singapore"
date: "January 2024"
date-modified: "`r Sys.Date()`"
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---


rmb always check for duplicates

## **Objectives**

Geospatial analytics hold tremendous potential to address complex problems facing society. In this study, you are tasked to apply appropriate spatial point patterns analysis methods to discover the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore.

## **The Task**

The specific tasks of this take-home exercise are as follows:

-   Using appropriate function of **sf** and **tidyverse**, preparing the following geospatial data layer in sf tibble data.frames:

    -   Grab taxi location points either by origins or destinations.

    -   Road layer within Singapore excluding outer islands.

    -   Singapore boundary layer excluding outer islands

-   Using the extracted data, derive traditional Kernel Density Estimation layers. (Hands-on ex3:1st order)

-   Using the extracted data, derive either Network Kernel Density Estimation (NKDE) or Temporal Network Kernel Density Estimation (TNKDE)

-   Using appropriate **tmap** functions, display the kernel density layers on openstreetmap of Singapore.

-   Describe the spatial patterns revealed by the kernel density maps.

# **Import R packages**

The different R packages used:

1.  **sf**: This package is used for importing, managing, and processing geospatial data. It provides classes and methods for working with spatial data in a simple and efficient manner.

2.  **tidyverse**: While not a single package, the tidyverse is a collection of R packages (including dplyr, ggplot2, tidyr, etc.) that share common principles for data manipulation and visualization. It's known for its user-friendly syntax and consistency.

3.  **tmap**: tmap is a package used for creating thematic maps. It provides a flexible and easy-to-use framework for visualizing spatial data, allowing users to create informative and visually appealing maps.

4.  **maptools**: This package offers a set of tools for manipulating geographic data. It includes functions for reading and writing spatial data in various formats, as well as tools for geometric operations on spatial data.

5.  **raster**: The raster package is designed for working with gridded spatial data. It allows users to read, write, manipulate, analyze, and model raster data, which is commonly used in fields like remote sensing and environmental sciences.

6.  **spatstat**: spatstat is used for performing spatial point pattern analysis. It provides a comprehensive set of tools for statistical analysis of point patterns, which is useful in fields such as ecology, epidemiology, and geography.

7.  **sfdep**: This package appears to be specific to your project and may not be a widely known package as of my last knowledge update in January 2022. It seems to be used for analyzing spatial dependencies, possibly building on or extending functionality provided by other spatial analysis packages.

8.  **pacman**: The **`pacman`** package is a convenient tool for managing and loading R packages. It allows you to install and load multiple packages in a single line of code.


```{r}
pacman::p_load(maptools, tidyverse, sf, raster, spatstat, tmap,lubridate, arrow, sp, dplyr)
```


# **The Data**

### **Apstial data**

-   For the purpose of this assignment, [Grab-Posisi](https://engineering.grab.com/grab-posisi) of Singapore will be used.

### **Geospatial data**

-   Road data set from OpenStreetMap of [Geofabrik download server](https://download.geofabrik.de/). The Malaysia, Singapore, and Brunei coverage should be downloaded.

-   Master Plan 2019 Subzone Boundary (No Sea) from Data.gov.sg.

# **Importing Data**

## Importing Aspatial Data

### Importing Grab-Posisi Dataset

In this case we use **arrow** package *`read_parquet()`* function to import the following dataset.


```{r}
grab <- read_parquet("data/apstial/GrabPosisi/part-00000.parquet")
```


Now we will use glimpse() of dplyr package is used to display the structure of df tibble data.frame.


```{r}
glimpse(grab)
```


Notice that pingtimestamp is in wrong data type format. It should be in date/ time format and not integer.

## Importing Geospatial data

### Importing Master Plan 2019 Subzone Boundary (No Sea) from Data.gov.sg.


```{r}
mpsz = st_read("data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml") %>%
  st_transform(crs=3414)
```

```{r}
glimpse(mpsz)
```



### Importing data for Road data from OpenStreetMap

In this case we will only be using road data?? \*\* To ask if we need road data or Bus or Mrt Only???


```{r}
road <- st_read(dsn = "data/geospatial", layer = "gis_osm_roads_free_1") %>%
  st_transform(crs=3414)
```


# Data Preparation

## Geospatial

### Remove z coordinates from the 'road' and 'mpsz' spatial objects.


```{r}
road <- st_zm(road)
```

```{r}
mpsz <- st_zm(mpsz)
```


Display summaries of the 'road' and 'mpsz' spatial objects.


```{r}
summary(road)
```

```{r}
summary(mpsz)
```


### Selecting and cleaning relevant information

Perform a spatial intersection between 'road' and 'mpsz', resulting in the 'road_sg' spatial object.


```{r}
road_sg <- st_intersection(road, mpsz)
```


Display a glimpse of the 'road_sg' spatial object.


```{r}
glimpse(road_sg)
```


Plot the 'road_sg' spatial object.


```{r}
plot(road_sg)
```


Creating the outline of Singapore


```{r}
mpsz <- mpsz %>%
  st_union()
```


Plotting to visualise


```{r}
plot(mpsz)
```



## Aspatial

### Converting data type to date/time format

Since pingtimestamp is in wrong data type format, we need to convert the data type of pingtimestamp from character to date-time.


```{r}
grab$pingtimestamp <- as_datetime(grab$pingtimestamp)
```


Save the tidy data.frame into rds format for subsequent use. Save the reformatted df into a new rds file called part0.rds. Save the output into a sub-folder call rds.


```{r}
write_rds(grab, "data/rds/part0.rds")
```


### Selecting the relevant information for Grab

### Task 1: Grab taxi location points either by origins or destinations.

### Extracting trips' origin locations


```{r}
origin_df <- grab %>% 
  group_by(trj_id) %>% 
  arrange(pingtimestamp) %>% 
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label=TRUE,
                        abbr=TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
```


## Extracting trips' destination locations


```{r}
destination_df <- grab %>%
  group_by(trj_id) %>%
  arrange(desc(pingtimestamp)) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label=TRUE,
                        abbr=TRUE),
         end_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
```


Saving data from future use


```{r}
write_rds(origin_df, "data/rds/origin_df.rds")
write_rds(destination_df, "data/rds/destination_df.rds")
```


### Importing the origin and destination data


```{r}
origin_df <- read_rds("data/rds/origin_df.rds")
destination_df <- read_rds("data/rds/destination_df.rds")
```


# **Data Preprocessing**

## Aspatial Data

### Convert Aspatial to Geospatial for GrabPosisi

Convert origin_df into an sf tibble data.frame by using it’s location information.


```{r}
origin_sf <- st_as_sf(origin_df,
                      coords = c("rawlng", "rawlat"),
                      crs = 4326) %>%
  st_transform(crs = 3414)
```

```{r}
destination_sf <- st_as_sf(destination_df,
                      coords = c("rawlng", "rawlat"),
                      crs = 4326) %>%
  st_transform(crs = 3414)
```

```{r}
glimpse(origin_sf)
```


### Visualising the data for Origin and Destination

#### Visualising frequency distribution

Here we are going to use ggplot functions are used to reveal the distribution of origin trips by day of the week. 


```{r}
ggplot(data=origin_df, 
       aes(x=weekday)) + 
  geom_bar()
```


Here we are going to use ggplot functions are used to reveal the distribution of destination trips by day of the week.


```{r}
ggplot(data=destination_df, 
       aes(x=weekday)) + 
  geom_bar()
```


#### Visualising as Point Symbol Map


```{r}
tmap_mode("plot")
tm_shape(origin_sf) +
  tm_dots()
```

```{r}
tmap_mode("plot")
tm_shape(destination_sf) +
  tm_dots()
```


## Project Transformation

First we can check the content of a simple feature data frame

Using st_geometry() The column in the sf data.frame that contains the geometries is a list, of class sfc. We can retrieve the geometry list-column.


```{r}
st_geometry(mpsz)
```


We can use this to double check if all the data is in projected coordinate system `SVY21`

Using glimpse() to find the basic feature information


```{r}
glimpse(mpsz)
```


Before, we proceed lets use double check and make sure that all the data are projected in the same projection system.

We can do so using st_crs() function


```{r}
st_crs(origin_sf)
```

```{r}
st_crs(destination_sf)
```

```{r}
st_crs(road_sg)
```


# Mapping the geospatial data sets

After we check the geospatial data set, we can plot a map to show the spatial patterns


```{r}
tmap_mode("plot")
```


Plotting the mpsz data


```{r}
tm_shape(mpsz) +
  tm_polygons()
```


Plotting road data


```{r}
tm_shape(road_sg)+
  tm_lines()
```


Mpaaing both origin and mpsz:


```{r}
tmap_mode("plot")
tm_shape(origin_df) +
  tm_dots() +
tm_shape(mpsz) +
  tm_polygons()
```



# Data Wrangling

## Converting sf data frames to sp’s Spatial\* class

Uses as_Spatial() of sf package to convert the three geospatial data from simple feature data frame to sp’s Spatial* class.


```{r}
origin_sf <- as_Spatial(origin_sf)
mpsz <- as_Spatial(mpsz)
road_sg <- as_Spatial(road_sg)
```


Now, we will display the information about these 3 Spatial\* class


```{r}
origin_sf
```

```{r}
mpsz
```

```{r}
road_sg
```


We can see and make sure that the geospatial data have been converted into their respective sp's Spatial classes now

## Converting the Spatial\* class into generic sp format

spatstat requires the analytical data in ppp object form. There is no direct way to convert a Spatial* classes into ppp object. We need to convert the Spatial classes* into Spatial object first.


```{r}
origin_sp <- as(origin_sf, "SpatialPoints")
roadsg_sp <- as(road_sg, "SpatialLines")
mpsz_sp <- as(mpsz, "SpatialPolygons")
```


Let us double check the sp objects properties:


```{r}
origin_sp
```

```{r}
roadsg_sp
```

```{r}
mpsz_sp
```


## Converting the generic sp format into spatstat’s ppp format


```{r}
origin_ppp <- as(orgin_sp, "ppp")
origin_ppp
```


Lets plot to examine:


```{r}
plot(origin_ppp)
```


Lets look at the summary statistics of the newly created ppp object:


```{r}
summary(origin_ppp)
```


Notice if there is any duplicates. In spatial point patterns analysis an issue of significant is the presence of duplicates. The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are simple, that is, that the points cannot be coincident.

## Handling duplicated points

To check the duplication in a ppp object:


```{r}
any(duplicated(origin_ppp))
```


To count the number of co-indicence point, we will use the multiplicity() function:


```{r}
multiplicity(origin_ppp)
```


How many locations have more than one point event


```{r}
sum(multiplicity(origin_ppp) > 1)
```


Lets view the locations of these duplicate point events


```{r}
tmap_mode('view')
tm_shape(origin_sf) +
  tm_dots(alpha=0.4, 
          size=0.05)
```


## Handling duplicated points

### Jittering

which will add a small perturbation to the duplicate points so that they do not occupy the exact same space.


```{r}
origin_ppp_jit <- rjitter(origin_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```


Check if there is still any duplicate points


```{r}
any(duplicated(origin_ppp_jit))
```


# Creating an owin object 

## Creating coastal outline


```{r}
sg_owin <- as(mpsz, "owin")
```


This is for mpsz need to map the outline first


```{r}
summary(sg_owin)
```


# Combining point events object and owin object


```{r}
originSG_ppp = origin_ppp[sg_owin]
```


Now let's take a look at the output


```{r}
summary(originSG_ppp)
```


# First-order Spatial Point Patterns Analysis

## Kernel Density Estimation

### Computing kernel density estimation using automatic bandwidth selection method


```{r}
kde_originSG_bw <- density(originSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
plot(kde_originSG_bw)
```

```{r}
bw <- bw.diggle(originSG_ppp)
bw
```


### Rescalling KDE values


```{r}
originSG_ppp.km <- rescale(originSG_ppp, 1000, "km")
```

```{r}
kde_originSG.bw <- density(originSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_originSG.bw)
```


### Working with different automatic Bandwidth methods


```{r}

```


### Working with different kernel methods



```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

