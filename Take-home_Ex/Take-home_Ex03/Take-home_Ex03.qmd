---
title: "Take Home Exercise 3"
---

Take-home Exercise 3 will be similar to one of the prototype module prepared above in term of content but with the following differences:

-   You are required to prepare the prototype module report as Take-home Exercise 3 submission. This mean, it has to be published on your own coursework page.

-   You are required to include a section called UI design for the different components of the UIs for the proposed design.

In this take-home exercise, you are required to select one of the module of your proposed Geospatial Analytics Shiny Application and complete the following tasks:

-   To evaluate and determine the necessary R packages needed for your Shiny application are supported in R CRAN,

-   To prepare and test the specific R codes can be run and returned the correct output as expected,

-   To determine the parameters and outputs that will be exposed on the Shiny applications, and

-   To select the appropriate Shiny UI components for exposing the parameters determine above.

# Required R packages for First and Second Order Spatial Point Patterns

1.  **tidyverse:**

    -   Purpose: A collection of packages for data manipulation and visualization, emphasizing a consistent and tidy data format.

    -   Relevance to spatial order: Useful for cleaning and transforming spatial data into a structured format that facilitates analysis.

2.  **knitr:**

    -   Purpose: Dynamic report generation in R, allowing integration of R code and results into documents.

    -   Relevance to spatial order: Enables the creation of documents that include spatial analysis results, making it easier to communicate and share findings.

3.  **rgdal:**

    -   Purpose: Provides bindings to the GDAL (Geospatial Data Abstraction Library) for reading and writing geospatial data formats.

    -   Relevance to spatial order: Essential for handling spatial data in various formats, ensuring interoperability and compatibility.

4.  **maptools:**

    -   Purpose: Tools for reading and handling spatial objects, particularly shapefiles.

    -   Relevance to spatial order: Facilitates the manipulation and analysis of spatial data, especially when dealing with shapefiles.

5.  **sf:**

    -   Purpose: Supports simple features for spatial data representation and manipulation.

    -   Relevance to spatial order: Offers a modern and efficient way to handle spatial data, including points, lines, and polygons.

6.  **raster:**

    -   Purpose: Deals with gridded spatial data, such as satellite imagery or climate data.

    -   Relevance to spatial order: Useful for working with raster data, which involves spatial information arranged in a grid.

7.  **spatstat:**

    -   Purpose: Analyzing spatial point patterns and processes.

    -   Relevance to spatial order: Particularly focused on the first point spatial order, addressing the distribution and arrangement of individual points in space.

8.  **tmap:**

    -   Purpose: Creates thematic maps for visualizing spatial data.

    -   Relevance to spatial order: Helps in visually exploring and interpreting spatial patterns in data.

9.  **tmaptools:**

    -   Purpose: Provides additional tools for working with thematic maps.

    -   Relevance to spatial order: Complements tmap by offering additional functionalities for spatial data visualization.

10. **gridExtra:**

    -   Purpose: Extends the grid graphics system to arrange multiple grid-based figures on one page.

    -   Relevance to spatial order: Useful for creating complex layouts when visualizing multiple spatial plots or maps.

11. **leaflet:**

    -   Purpose: Creates interactive web maps using JavaScript.

    -   Relevance to spatial order: Enables the development of interactive maps, enhancing the exploration of spatial relationships and patterns.

12. **OpenStreetMap:**

    -   Purpose: Accesses and interacts with OpenStreetMap data.

    -   Relevance to spatial order: Allows integration of OpenStreetMap data into spatial analysis, providing additional context to spatial patterns.

13. **ggstatsplot:**

    -   Purpose: Enhances ggplot2 with statistical summaries and plots.

    -   Relevance to spatial order: Can be used for adding statistical summaries to spatial visualizations created with ggplot2.

14. **statsExpressions:**

    -   Purpose: Creates customizable expressions for statistical summaries.

    -   Relevance to spatial order: Useful for customizing the presentation of statistical information in spatial analysis results.

15. **lubridate:**

    -   Purpose: Facilitates the manipulation of date-time objects.

    -   Relevance to spatial order: Helps in handling temporal aspects of spatial data, which is crucial in understanding how spatial patterns change over time.

```{r}
pacman::p_load(tidyverse, knitr, rgdal, maptools, sf,raster,spatstat, tmap,tmaptools, gridExtra, leaflet, OpenStreetMap, ggstatsplot, statsExpressions, lubridate, raster, gridExtra, skimr, rstantools)
```

# Data that is available from Airbnb

[InsideAirbnb provides a snapshot of the following information:]{.underline}

-   Listings - Summary information on listings

-   Detailed Listings - Detailed listing information of airbnb for rent

-   Calendar - Detailed calendar data for listings

-   Reviews - Summary review data

-   Detailed Reviews - Detailed review data for listings

-   Neighbourhoods - list of neighbourhoods in the city and a neighbourhood GeoJSON file

## Readind data from Airbnb

```{r}
listings <- read_csv("data/listings.csv")
d_listings <- read_csv("data/detailedlistings.csv")
calendar <- read_csv("data/calendar.csv")
reviews <- read_csv("data/reviews.csv")
d_reviews <- read_csv("data/detailedreviews.csv")
neighbourhoods <- read_csv("data/neighbourhoods.csv")
```

## Reading Spatial data from Airbnb

```{r}
nhood_map_sf <- st_read(dsn = "data/neighbourhoods.geojson", 
                        layer="neighbourhoods") %>%
                st_transform(crs = 3414)
```

# Data Cleaning

```{r}
glimpse(listings)
glimpse(reviews)
glimpse(d_reviews)
glimpse(calendar)
glimpse(d_listings)
```

Change the data type of id to characters

```{r}
listings <- listings %>% mutate_at(vars(id, host_id), as.character)
reviews <- reviews %>% mutate_at(vars(listing_id), as.character)
d_reviews <- d_reviews %>% mutate_at(vars(id, reviewer_id, listing_id), as.character)
calendar <- calendar %>% mutate_at(vars(listing_id), as.character)
d_listings <- d_listings %>% mutate_at(vars(host_id, id), as.character)
```

Change price in detailed listings to numerical & remove $ and, symbol in cloumns where currency is read as character.

```{r}
strip_dollars = function(x) {as.numeric(gsub("[\\$,]", "", x))}
d_listings[,61:65] <- sapply(d_listings[,61:65], strip_dollars)
d_listings[,67] <- sapply(d_listings[,67], strip_dollars)
```

## Check for Missing Data 

We check if there is any missing data and decide how to handle it. Missing data will include zero value, which we need to change to be able to analyse correctly.

### Listings data 

```{r}
skim(listings)
```

### Calender

```{r}
skim(calendar)
```

### Reviews and Detailed Reviews

```{r}
skim(reviews)
```
```{r}
skim(d_reviews)
```

### Detailed Listings

```{r}
skim(d_listings)
```


# Data Wrangling

We need to convert the listings data into sf object. 

```{r}
listings_sf <- listings %>% 
                st_as_sf(coords = c("longitude", "latitude"),
                         crs = 4326) %>%
                st_transform(crs = 3414)
```

Display the 10 records and show the geometry type and we can check that projected CRIS is svy21.

```{r}
head(listings_sf)
```

Show the point details of the geometry column, givin gthe x, y coordianted in SVY21

```{r}
glimpse(listings_sf)
```

# Data Analysis

## Type of Accomdation

### Room types by region

Summarizing the types of listings by neighbourhood groups

```{r}
regionlist <- listings %>%
              group_by(neighbourhood_group, room_type) %>%
              summarise(
                num_listings = n(),
                avg_price = mean(price),
                med_price = median(price))
```
Plotting the type of accomdation by region

```{r}
ggplot(regionlist, aes(x=room_type, fill = room_type)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) + 
      geom_col(aes(y = num_listings)) +
      facet_grid(cols=vars(neighbourhood_group), margins = T, labeller = labeller(neighbourhood_group = label_wrap_gen(width = 5, multi_line = TRUE))) +
      labs(x = "", y = "No. of listings", fill = "Room Type")
```

## Pricing of Room Types

Remove price outliers

```{r}
outlier_price <- quantile(listings$price, 0.99, na.rm = TRUE)
listings_cleanprice <- listings %>% filter(price <= outlier_price)
```

Plot boxplot of prices for each room type

```{r}
p1 <- ggplot(listings, aes(x=room_type, fill = room_type)) + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = "None") + 
  geom_boxplot(aes(y=price)) +
  labs(x = "", y = "Listing Price", fill = "Room Type", title = "Listing price")
```

Cleaned pricing

```{r}
p2 <- ggplot(listings_cleanprice, aes(x=room_type, fill = room_type)) + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) + 
  geom_boxplot(aes(y=price)) +
  labs(x = "", y = "Listing Price", fill = "Room Type", title = "Listing price (outliers removed)")

grid.arrange(p1, p2, nrow = 1)

```

## Room Types by Price and Region

```{r}
ggplot(listings_cleanprice, aes(x=neighbourhood_group, fill = neighbourhood_group)) + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  geom_boxplot(aes(y=price)) +
  facet_grid(~room_type, labeller = labeller(room_type = label_wrap_gen(width = 5, multi_line = TRUE))) +
  labs(x = "", y = "Listing Price", fill = "Region")
```

# Deductive Data Analysis

We utilize ggstatsplot to conduct confirmatory data analysis on prices across various neighborhoods. Our null hypothesis posits that there is no difference in listing prices among different neighborhood groups. We reject this hypothesis if the p-value exceeds 0.05 at a 95% significance level. Initially, we extract only the necessary variables (neighbourhood_group, room_type, and price) and feed them into the ggbetweenstats() function. This function generates the p-value and a violin plot illustrating listing prices categorized by neighborhood group. Additionally, it computes pairwise comparisons between the grouped variables, displaying only the significant comparisons along with their respective p-values.

```{r}
conftest <- listings_cleanprice %>% dplyr::select(neighbourhood_group, room_type, price)
ggbetweenstats(
  data = conftest,
  x = neighbourhood_group,
  y = price
)
```

```{r}
conftest2 <- conftest %>% filter(room_type != "Shared room", room_type != "Hotel room")
grouped_ggbetweenstats(
  data = conftest2,
  x = neighbourhood_group,
  y = price,
  grouping.var = room_type,
  ggsignif.args = list(textsize = 4, tip_length = 0.01),
  p.adjust.method = "bonferroni", # method for adjusting p-values for multiple comparisons
  # adding new components to `ggstatsplot` default
  ggplot.component = list(ggplot2::scale_y_continuous(sec.axis = ggplot2::dup_axis())),
  k = 3,
  title.prefix = "Room Type",
  palette = "default_jama",
  package = "ggsci",
  plotgrid.args = list(nrow = 2),
  title.text = "Differences in listing prices by neighbourhoods for different room types"
)
```

```{r}
sharedrooms <- conftest %>% filter(room_type == "Shared room")
 ggbetweenstats(
   data = sharedrooms,
   x = neighbourhood_group,
   y = price
)
```

4.2 Hosts & Listings
4.2.1 Hosts with multiple listings

# Spatial Distribution of Airbnb listings in Singapore

## Handling Spatial Data Outliers

Identify listings that fall within the Water Cachement Area

```{r}
filter(listings, neighbourhood == "Central Water Catchment")
```
Remove listings in the Central Water Catchment, Sungei Kadut and Mandai areas

```{r}
listings_clean <- filter(listings_sf, !neighbourhood %in% c("Central Water Catchment", "Sungei Kadut", "Mandai", "Western Water Catchment")) %>% st_as_sf()
```

## Mapping Airbnb listings in Singapore

### Loading basemap raster with bounding box

Read in OSM raster of listings data for plot view and create bounding box 

```{r}
sg_osm <- tmaptools::read_osm(listings_clean, ext=1.3)
bb_sg_osm <- st_bbox(listings_clean, crs = 3414)
```

#### Listing by room types and neighbourhood

Plotting neighbourhood listings on tmap

tmap_mode("view")

# Plotting points

tmap_options(check.and.fix = TRUE)  # Set option to check and fix invalid polygons
tm_basemap(leaflet::providers$OpenStreetMap) +
tm_shape(nhood_map_sf) +
  tm_polygons(alpha = 0.3) +
tm_shape(listings_clean) +
  tm_symbols(col="room_type", size = 0.2) +
  tm_view(set.zoom.limits = c(11, 17)) +
  tm_facets(by="room_type") +
  tm_layout(legend.show = FALSE)  # Change to FALSE for consistency




# Data that will be used for wrangling subzone map

-   MP14_SUBZONE_WEB_PL.shp

```{r}
mpsz_sf <- st_read(dsn = "data/geospatial",
                layer = "MP14_SUBZONE_WEB_PL")
```

# UI for Proposed Idea

## Kernel Density Estimation

![](images/Group%208.png)

## Second Order Analysis & Chloropleth Map

![](images/Group%2010.png)

![](images/Group%209.png)
