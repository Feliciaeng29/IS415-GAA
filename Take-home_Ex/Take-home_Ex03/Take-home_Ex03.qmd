---
title: "Take Home Exercise 3"
---

Take-home Exercise 3 will be similar to one of the prototype module prepared above in term of content but with the following differences:

-   You are required to prepare the prototype module report as Take-home Exercise 3 submission. This mean, it has to be published on your own coursework page.

-   You are required to include a section called UI design for the different components of the UIs for the proposed design.

In this take-home exercise, you are required to select one of the module of your proposed Geospatial Analytics Shiny Application and complete the following tasks:

-   To evaluate and determine the necessary R packages needed for your Shiny application are supported in R CRAN,

-   To prepare and test the specific R codes can be run and returned the correct output as expected,

-   To determine the parameters and outputs that will be exposed on the Shiny applications, and

-   To select the appropriate Shiny UI components for exposing the parameters determine above.

# Required R packages for First and Second Order Spatial Point Patterns

1.  **tidyverse:**

    -   Purpose: A collection of packages for data manipulation and visualization, emphasizing a consistent and tidy data format.

    -   Relevance to spatial order: Useful for cleaning and transforming spatial data into a structured format that facilitates analysis.

2.  **knitr:**

    -   Purpose: Dynamic report generation in R, allowing integration of R code and results into documents.

    -   Relevance to spatial order: Enables the creation of documents that include spatial analysis results, making it easier to communicate and share findings.

3.  **rgdal:**

    -   Purpose: Provides bindings to the GDAL (Geospatial Data Abstraction Library) for reading and writing geospatial data formats.

    -   Relevance to spatial order: Essential for handling spatial data in various formats, ensuring interoperability and compatibility.

4.  **maptools:**

    -   Purpose: Tools for reading and handling spatial objects, particularly shapefiles.

    -   Relevance to spatial order: Facilitates the manipulation and analysis of spatial data, especially when dealing with shapefiles.

5.  **sf:**

    -   Purpose: Supports simple features for spatial data representation and manipulation.

    -   Relevance to spatial order: Offers a modern and efficient way to handle spatial data, including points, lines, and polygons.

6.  **raster:**

    -   Purpose: Deals with gridded spatial data, such as satellite imagery or climate data.

    -   Relevance to spatial order: Useful for working with raster data, which involves spatial information arranged in a grid.

7.  **spatstat:**

    -   Purpose: Analyzing spatial point patterns and processes.

    -   Relevance to spatial order: Particularly focused on the first point spatial order, addressing the distribution and arrangement of individual points in space.

8.  **tmap:**

    -   Purpose: Creates thematic maps for visualizing spatial data.

    -   Relevance to spatial order: Helps in visually exploring and interpreting spatial patterns in data.

9.  **tmaptools:**

    -   Purpose: Provides additional tools for working with thematic maps.

    -   Relevance to spatial order: Complements tmap by offering additional functionalities for spatial data visualization.

10. **gridExtra:**

    -   Purpose: Extends the grid graphics system to arrange multiple grid-based figures on one page.

    -   Relevance to spatial order: Useful for creating complex layouts when visualizing multiple spatial plots or maps.

11. **leaflet:**

    -   Purpose: Creates interactive web maps using JavaScript.

    -   Relevance to spatial order: Enables the development of interactive maps, enhancing the exploration of spatial relationships and patterns.

12. **OpenStreetMap:**

    -   Purpose: Accesses and interacts with OpenStreetMap data.

    -   Relevance to spatial order: Allows integration of OpenStreetMap data into spatial analysis, providing additional context to spatial patterns.

13. **ggstatsplot:**

    -   Purpose: Enhances ggplot2 with statistical summaries and plots.

    -   Relevance to spatial order: Can be used for adding statistical summaries to spatial visualizations created with ggplot2.

14. **statsExpressions:**

    -   Purpose: Creates customizable expressions for statistical summaries.

    -   Relevance to spatial order: Useful for customizing the presentation of statistical information in spatial analysis results.

15. **lubridate:**

    -   Purpose: Facilitates the manipulation of date-time objects.

    -   Relevance to spatial order: Helps in handling temporal aspects of spatial data, which is crucial in understanding how spatial patterns change over time.

```{r}
pacman::p_load(tidyverse, knitr, rgdal, maptools, sf,raster,spatstat, tmap,tmaptools, gridExtra, leaflet, OpenStreetMap, ggstatsplot, statsExpressions, lubridate, raster, gridExtra, skimr, rstantools)
```

# Data that is available from Airbnb

[InsideAirbnb provides a snapshot of the following information:]{.underline}

-   Listings - Summary information on listings

-   Detailed Listings - Detailed listing information of airbnb for rent

-   Calendar - Detailed calendar data for listings

-   Reviews - Summary review data

-   Detailed Reviews - Detailed review data for listings

-   Neighbourhoods - list of neighbourhoods in the city and a neighbourhood GeoJSON file

## Readind data from Airbnb

```{r}
listings <- read_csv("data/listings.csv")
d_listings <- read_csv("data/detailedlistings.csv")
calendar <- read_csv("data/calendar.csv")
reviews <- read_csv("data/reviews.csv")
d_reviews <- read_csv("data/detailedreviews.csv")
neighbourhoods <- read_csv("data/neighbourhoods.csv")
```

## Reading Spatial data from Airbnb

```{r}
nhood_map_sf <- st_read(dsn = "data/neighbourhoods.geojson", 
                        layer="neighbourhoods") %>%
                st_transform(crs = 3414)
```

# Data Cleaning

```{r}
glimpse(listings)
glimpse(reviews)
glimpse(d_reviews)
glimpse(calendar)
glimpse(d_listings)
```

Change the data type of id to characters

```{r}
listings <- listings %>% mutate_at(vars(id, host_id), as.character)
reviews <- reviews %>% mutate_at(vars(listing_id), as.character)
d_reviews <- d_reviews %>% mutate_at(vars(id, reviewer_id, listing_id), as.character)
calendar <- calendar %>% mutate_at(vars(listing_id), as.character)
d_listings <- d_listings %>% mutate_at(vars(host_id, id), as.character)
```

Change price in detailed listings to numerical & remove $ and, symbol in cloumns where currency is read as character.

```{r}
strip_dollars = function(x) {as.numeric(gsub("[\\$,]", "", x))}
d_listings[,61:65] <- sapply(d_listings[,61:65], strip_dollars)
d_listings[,67] <- sapply(d_listings[,67], strip_dollars)
```

## Check for Missing Data 

We check if there is any missing data and decide how to handle it. Missing data will include zero value, which we need to change to be able to analyse correctly.

### Listings data 

```{r}
skim(listings)
```

### Calender

```{r}
skim(calendar)
```

### Reviews and Detailed Reviews

```{r}
skim(reviews)
```
```{r}
skim(d_reviews)
```

### Detailed Listings

```{r}
skim(d_listings)
```


# Data Wrangling

We need to convert the listings data into sf object. 

```{r}
listings_sf <- listings %>% 
                st_as_sf(coords = c("longitude", "latitude"),
                         crs = 4326) %>%
                st_transform(crs = 3414)
```

Display the 10 records and show the geometry type and we can check that projected CRIS is svy21.

```{r}
head(listings_sf)
```

Show the point details of the geometry column, givin gthe x, y coordianted in SVY21

```{r}
glimpse(listings_sf)
```

# Data Analysis

## Type of Accomdation

### Room types by region

Summarizing the types of listings by neighbourhood groups

```{r}
regionlist <- listings %>%
              group_by(neighbourhood_group, room_type) %>%
              summarise(
                num_listings = n(),
                avg_price = mean(price),
                med_price = median(price))
```
Plotting the type of accomdation by region

```{r}
ggplot(regionlist, aes(x=room_type, fill = room_type)) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) + 
      geom_col(aes(y = num_listings)) +
      facet_grid(cols=vars(neighbourhood_group), margins = T, labeller = labeller(neighbourhood_group = label_wrap_gen(width = 5, multi_line = TRUE))) +
      labs(x = "", y = "No. of listings", fill = "Room Type")
```

## Pricing of Room Types

Remove price outliers

```{r}
outlier_price <- quantile(listings$price, 0.99, na.rm = TRUE)
listings_cleanprice <- listings %>% filter(price <= outlier_price)
```

Plot boxplot of prices for each room type

```{r}
p1 <- ggplot(listings, aes(x=room_type, fill = room_type)) + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = "None") + 
  geom_boxplot(aes(y=price)) +
  labs(x = "", y = "Listing Price", fill = "Room Type", title = "Listing price")
```

Cleaned pricing

```{r}
p2 <- ggplot(listings_cleanprice, aes(x=room_type, fill = room_type)) + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) + 
  geom_boxplot(aes(y=price)) +
  labs(x = "", y = "Listing Price", fill = "Room Type", title = "Listing price (outliers removed)")

grid.arrange(p1, p2, nrow = 1)

```

## Room Types by Price and Region

```{r}
ggplot(listings_cleanprice, aes(x=neighbourhood_group, fill = neighbourhood_group)) + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  geom_boxplot(aes(y=price)) +
  facet_grid(~room_type, labeller = labeller(room_type = label_wrap_gen(width = 5, multi_line = TRUE))) +
  labs(x = "", y = "Listing Price", fill = "Region")
```

# Deductive Data Analysis

We utilize ggstatsplot to conduct confirmatory data analysis on prices across various neighborhoods. Our null hypothesis posits that there is no difference in listing prices among different neighborhood groups. We reject this hypothesis if the p-value exceeds 0.05 at a 95% significance level. Initially, we extract only the necessary variables (neighbourhood_group, room_type, and price) and feed them into the ggbetweenstats() function. This function generates the p-value and a violin plot illustrating listing prices categorized by neighborhood group. Additionally, it computes pairwise comparisons between the grouped variables, displaying only the significant comparisons along with their respective p-values.

```{r}
conftest <- listings_cleanprice %>% dplyr::select(neighbourhood_group, room_type, price)
ggbetweenstats(
  data = conftest,
  x = neighbourhood_group,
  y = price
)
```

```{r}
conftest2 <- conftest %>% filter(room_type != "Shared room", room_type != "Hotel room")
grouped_ggbetweenstats(
  data = conftest2,
  x = neighbourhood_group,
  y = price,
  grouping.var = room_type,
  ggsignif.args = list(textsize = 4, tip_length = 0.01),
  p.adjust.method = "bonferroni", # method for adjusting p-values for multiple comparisons
  # adding new components to `ggstatsplot` default
  ggplot.component = list(ggplot2::scale_y_continuous(sec.axis = ggplot2::dup_axis())),
  k = 3,
  title.prefix = "Room Type",
  palette = "default_jama",
  package = "ggsci",
  plotgrid.args = list(nrow = 2),
  title.text = "Differences in listing prices by neighbourhoods for different room types"
)
```

```{r}
sharedrooms <- conftest %>% filter(room_type == "Shared room")
 ggbetweenstats(
   data = sharedrooms,
   x = neighbourhood_group,
   y = price
)
```

# Hosts & Listings

## Host with multiple listings

Create a table of percetnage of hosts by number of listings

```{r}
list_byhost <- listings %>%
                group_by(host_id, host_name) %>%
                count(name = "number_of_listings", sort = TRUE) %>%
                ungroup() %>%
                group_by(number_of_listings) %>%
                count(name = "number_of_hosts")
```

Plot above table

```{r}
ggplot(list_byhost, aes(x=number_of_listings, y= number_of_hosts/sum(number_of_hosts)*100)) +
  geom_point() +
  labs(y="Percentage of hosts", title = "% of hosts vs number of listings", x = "number of listings")
```

To explore the whether the market is dominated by hosts with single or multiple listings, we plot a Pareto chart by adding the cumulative frequency of the number of listings of hosts, to a descending list of airbnb rentals by host. We see that almost 75% of the Airbnb ‘stock’ are taken up by hosts with multiple listings.

There are currently no regulations or legislation around the number of listings that a host may have, unlike in other cities that regulate the maximum number of listings (e.g. New York). People with more than 1 listing are likely to be agents managing these properties on behalf of landlords.

However, there are restrictions on the minimum stay for short term rentals: 3 months for private housing and 6 months for HDB flats. This means that typical tourist stays (e.g. 2-7 days) in Airbnb listings would technically be illegal. Despite this, 89% of listings have a minimum stay of less than the legislated minimum stay.

Create Pareto Chart

```{r}
list_byhost <- list_byhost[order(list_byhost$number_of_listings, decreasing = TRUE),]
list_byhost$number_of_listings1 <- factor(list_byhost$number_of_listings, levels = list_byhost$number_of_listings)
list_byhost$listfreq <- list_byhost$number_of_hosts * list_byhost$number_of_listings
list_byhost$cumul <- cumsum(list_byhost$listfreq)
nr <- nrow(list_byhost)
N <- sum(list_byhost$listfreq)
y2 <- c("  0%", " 10%", " 20%", " 30%", " 40%", " 50%", " 60%", " 70%", " 80%", " 90%", "100%")
ggplot(list_byhost, aes(x=number_of_listings1)) +
  geom_bar(aes(y=number_of_hosts), fill = "blue", stat = "identity") +
  geom_point(aes(x=number_of_listings1, y=cumul)) +
  geom_line(aes(x=number_of_listings1, y=cumul)) +
  geom_path(aes(y=cumul, group=1)) +
  labs(y="Frequency", title = "Pareto Chart of hosts and listings", x = "No. of listings") +
  theme(plot.margin = margin(c(1,1,1,1), unit="cm"), axis.text.x = element_text(angle=90, vjust=0.6)) +
  annotate("text", x = nr + 3, y = seq(0, N, N/10), label = y2, size = 3.5, hjust = "inward")
```

#### Distribution of host type and room type

Create column with single or multiple host types

```{r}
listings <- listings %>% mutate(host_type = ifelse(calculated_host_listings_count ==1, "Single", "Multiple"))
```

```{r}
mosaicplot(listings$room_type ~ listings$host_type, color = c("steelblue", "wheat"), xlab = "Room Type", ylab = "Host Type", main = "Mosaic Plot of Room Type and Host Type")
```


Most hosts with Single listings mainly offer private rooms, followed by shared rooms. This suggests they're likely renting out their extra or shared bedrooms to earn extra money. On the other hand, hosts offering entire homes or apartments might own investment properties or be away during the rental period. There are also a few hosts with single hotel room listings, which could be because of mistakes in the room type or because they offer special or boutique accommodations. Usually, hotel operators have multiple listings, so these single hotel room listings might be unique.


#### Analysis of price of room types by single or multiple hosts

```{r}
# Set seed for reproducibility
set.seed(123)
test2 <- listings %>% dplyr::select(room_type, host_type, neighbourhood_group, price)
grouped_ggbetweenstats(
  data = test2,
  x = host_type,
  y = price,
  grouping.var = room_type,
  ggsignif.args = list(textsize = 4, tip_length = 0.01),
  p.adjust.method = "bonferroni", # method for adjusting p-values for multiple comparisons
  # adding new components to `ggstatsplot` default
  ggplot.component = list(ggplot2::scale_y_continuous(sec.axis = ggplot2::dup_axis())),
  k = 3,
  title.prefix = "Room Type",
  palette = "default_jama",
  package = "ggsci",
  plotgrid.args = list(nrow = 2),
  title.text = "Differences in listing prices for single/multiple hosts by different room types"
)
```



```{r}
grouped_ggbetweenstats(
  data = test2 %>% filter(room_type != "Hotel room"),
  x = host_type,
  y = price,
  grouping.var = neighbourhood_group,
  ggsignif.args = list(textsize = 4, tip_length = 0.01),
  p.adjust.method = "bonferroni", # method for adjusting p-values for multiple comparisons
  # adding new components to `ggstatsplot` default
  # ggplot.component = list(ggplot2::scale_y_continuous(sec.axis = ggplot2::dup_axis())),
  # k = 3,
  title.prefix = "Room Type",
  palette = "default_jama",
  package = "ggsci",
  # plotgrid.args = list(nrow = 2),
  title.text = "Differences in listing prices for single/multiple hosts by different neighbourhoods", 
  output = "subtitle"
)
```

## Which year did the hosts join airbnb

```{r}
host_byyear <- d_listings %>% dplyr::select(id, host_id, host_since) %>% group_by(year_joined = year(host_since)) %>% drop_na() %>% summarise(number_hosts = n()) %>% ungroup() %>% mutate(change = (number_hosts - lag(number_hosts)) / lag(number_hosts)*100)

ggplot(host_byyear, aes(x=year_joined, y = number_hosts)) + geom_bar(stat = "identity", fill = "steelblue") + 
   labs(title = "New hosts by year", y = "No. of hosts joined", x = "year") +
   geom_text(aes(label = number_hosts), vjust = -0.3)
```


## Detailed Information on Hosts

How many listings do not have reviews

```{r}
d_listings %>% filter(., host_acceptance_rate == "0%" | is.na(host_acceptance_rate)) %>% dplyr::select(id, host_acceptance_rate, number_of_reviews) %>% arrange(desc(number_of_reviews))
```

# Reviews

## Listings with no reviews

```{r}
no_reviews <- listings_sf %>% filter(is.na(last_review))
host_join <- d_listings %>% dplyr::select(id, host_since)
no_reviews_host <- left_join(no_reviews, host_join, by = c("id")) %>% group_by(year_joined = year(host_since)) %>% summarise(number_hosts = n()) %>% drop_na()  %>% ungroup()
```

```{r}
no_reviews_host$year_joined = as.character(no_reviews_host$year_joined)
ggplot(no_reviews_host, aes(x=year_joined, y = number_hosts)) + geom_bar(stat = "identity", fill = "steelblue4") + 
   labs(title = "Listings with no reviews - Hosts by year", y = "No. of hosts joined", x = "year") + geom_text(aes(label = number_hosts), vjust = -0.3) + scale_x_discrete(breaks = no_reviews_host$year_joined)
```

## Review score

select relevant data for review scores

```{r}
review_scores <- d_listings %>% dplyr::select(id, host_id, number_of_reviews, room_type, review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_communication, review_scores_checkin, review_scores_location, review_scores_value, reviews_per_month)
```

Plot histogram of overall rating

```{r}
ggplot(review_scores, aes(x=review_scores_rating)) + geom_histogram(aes(fill = room_type), bins = 20) + stat_bin(aes(label = ..count..), bins = 20, size = 3, geom= "text", vjust = -1)
```

### Dsitribution of overall review score

Plot histogram of attribute score

```{r}
ggplot(gather(review_scores[, -c(1:5,12)], cols, value), aes(x = value)) + 
       geom_histogram(binwidth = 1) + facet_grid(.~cols)
```

# Spatial Distribution of Airbnb listings in Singapore

## Handling Spatial Data Outliers

Identify listings that fall within the Water Cachement Area

```{r}
filter(listings, neighbourhood == "Central Water Catchment")
```
Remove listings in the Central Water Catchment, Sungei Kadut and Mandai areas

```{r}
listings_clean <- filter(listings_sf, !neighbourhood %in% c("Central Water Catchment", "Sungei Kadut", "Mandai", "Western Water Catchment")) %>% st_as_sf()
```

## Mapping Airbnb listings in Singapore

### Loading basemap raster with bounding box

Read in OSM raster of listings data for plot view and create bounding box 

```{r}
sg_osm <- tmaptools::read_osm(listings_clean, ext=1.3)
bb_sg_osm <- st_bbox(listings_clean, crs = 3414)
```

#### Listing by room types and neighbourhood

Plotting neighbourhood listings on tmap




#### Rental prices by room type




# Data that will be used for wrangling subzone map

-   MP14_SUBZONE_WEB_PL.shp

```{r}
mpsz_sf <- st_read(dsn = "data/geospatial",
                layer = "MP14_SUBZONE_WEB_PL")
```

# UI for Proposed Idea

## Kernel Density Estimation

![](images/Group%208.png)

## Second Order Analysis & Chloropleth Map

![](images/Group%2010.png)

![](images/Group%209.png)
